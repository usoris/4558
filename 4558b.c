#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in6,    flippot,        sensorPotentiometer)
#pragma config(Sensor, in7,    liftpot,        sensorPotentiometer)
#pragma config(Sensor, dgtl11, secondary,      sensorDigitalIn)
#pragma config(Sensor, dgtl12, primary,        sensorDigitalIn)
#pragma config(Sensor, I2C_1,  RS,             sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  LS,             sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           LS,            tmotorVex269, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           RS,            tmotorVex269, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           LLT,           tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           RLT,           tmotorVex393, openLoop)
#pragma config(Motor,  port8,           FLIPPER,       tmotorVex393, openLoop)
#pragma config(Motor,  port9,           intake,        tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
bool drivey = true;
int threshold = 25;
int max = 485;
int mid = 1170; // assuming its directly middle
int min = 1730;

int flipmax = 485;
int flipmin = 1735;
int flipmid = 670;
bool hold;



//rs-right side 			ls-left side
//RLB- right lift bottom motor 		RLT- right lift top motor
//LLB- left lift bottom motor 		LLT- left lift top motor
//flip- flipper
//intake- intake


void leftside(int leff)		//controls left side of drive for easy port change and more simplifed code
{
	motor[LS] = leff;
}
void rightside(int reight)//controls right side of drive for easy port change and more simplified code
{
	motor[RS] = reight;
}
void lifting(int x)		//sets all the lifts to a single value
{
//	motor[RLB] = x;
	motor[RLT] = x;

	motor[LLT] = x;
//	motor[LLB] = x;
}

void intakk(int go)
{
	motor[intake] =  go;
}


task liftmid()		//holds the lifts at a middle level so horizontal bars are parallel to the ground as long as hold is true
{
	while(hold)
	{
	if(SensorValue[liftpot] > mid-200)		 //potentiometer is reversed so values are flipped, lowest pot value is max and largest value is min
	{
		lifting(127);
	}
/*	else if(SensorValue[liftpot] < mid+200)
	{
		lifting(-127);
	}*/
	else			//this part is unnessarry but i'm too lazy to take it out
	{
		lifting(0);
	}
}
lifting(0);
}


void flip()			//this is the flipper code, pretty junky
{
	if(vexRT[Btn8D] == 1)// && SensorValue[flippot] > flipmax)
	{
		motor[FLIPPER] = -127;				//	this is where i would use the motor for my flipper, IF I HAD ONE!
	}
	else if (vexRT[Btn8U] ==1)// && SensorValue[flippot] < flipmin)
	{
		motor[FLIPPER] = 127;
	}
	else
	{
		motor[FLIPPER] = 0;
	}
}

void forward()					//drives the robot forwards
{
	leftside(127);
	rightside(127);
}

void halt()							//stops the robot
{
	leftside(0);
	rightside(0);
}

void backward()					//drives robot backwards
{
	leftside(-127);
	rightside(-127);
}





/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()	// autonomous STARTS INTAKE -> MOVES LIFTS TO CORRECT POSITION WHILE FORWARD -> MAKES INTAKE REVERSE -> STOPS -> IDLES FOR 1 SECOND -> GOES BACKWARDS FOR 1 SECOND -> STOPS
{

if(primary)
{
	nMotorEncoder[LS] = 0;
	motor[FLIPPER] = 127;
	intakk(127);
	wait1Msec(200);
	motor[FLIPPER] = 127;
	wait1Msec(200);
	motor[FLIPPER] = 0;
	hold = true;
	StartTask(liftmid);
	while(nMotorEncoder[LS] > -1800)//LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOOLOLOLOLOLOLOLOLOLOLOLOLOLOL
	{
		motor[LS] = 127;
		motor[RS] = 127;
	}
	halt();
//	forward();
nMotorEncoder[LS] = 0;
while(nMotorEncoder[LS] < 1800)
{
	backward();
}
halt();
wait1Msec(1000);
nMotorEncoder[LS] = 0;
nMotorEncoder[RS] = 0;
	while(nMotorEncoder[LS] > -1000)
	{
		motor[LS] = 127;
		motor[RS] = 127;
	}
	halt();
/*
while(nMotorEncoder[LS] > -200)
{
	motor[LS] = 127;
	motor[RS] = -127;
}
nMotorEncoder[LS] = 0;
nMotorEncoder[RS] = 0;
	while(nMotorEncoder[LS] > -1000)
	{
		motor[LS] = 127;
		motor[RS] = 127;
	}

*/
	hold = false;
	halt();
	intakk(-127);
}
/*
if(secondary)
{
	leftside(127);
	rightside(-127);

}
*/
}


void nomnomatron()	//controls intake
{
	if(vexRT[Btn6U] + vexRT[Btn6D] > 0)//If either button is pressed then it will decide if in or out and spin intake accordingly
	{
		if(vexRT[Btn6U])				//takes in balls
		{
			motor[intake] = 127;
		}
		if(vexRT[Btn6D])				// spits out balls
		{
			motor[intake] = -127;
		}
	}
	else
	{
		motor[intake] = 0;			// no input do nothing
	}

}

void manuallift()										// allows lift to be controlled manually, if it goes too high, motors will stop being powered to prevent stress on motors
{
		if(vexRT[Btn5U] && SensorValue[liftpot] > max)
		{
			lifting(127);
		}
		else if(vexRT[Btn5D] && SensorValue[liftpot] < min)
		{
			lifting(-127);
		}
		else
		{
			lifting(0);
		}

}



void makro()			// makes lifts go all the way up or all the way down.
{
	if(vexRT[Btn5U])
	{
		while(SensorValue[liftpot] > max) //potentiometer is reversed so values are flipped, lowest pot value is max and smallest
		{
			lifting(127);

			if(vexRT[Btn7U]) //if the switch drive button is pressed, break out of the loop
				break;

		}
		lifting(0);
	}

	if(vexRT[Btn5D])
	{
		while(SensorValue[liftpot] < min) //potentiometer is reversed so values are flipped, lowest pot value is max and smallest
		{
			if(vexRT[Btn7U]) //if the switch drive button is pressed, break out of the loop
				break;

			lifting(-127);
		}
		lifting(0);
	}
}




task omnidrive()	// controls the drive of the omniwheel drive train
{
	while(true)
	{
		//RIGHT SIDE
		if(abs(vexRT[Ch2]) > threshold)
		{
			rightside(vexRT[Ch2]);
		}
		else
		{
			rightside(0);
		}


		//LEFT SIDE
		if(abs(vexRT[Ch3]) > threshold)
		{
			leftside(vexRT[Ch3]);

		}
		else
		{
			leftside(0);
		}

	}
}






/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()	//STARTS ALL DA CODE YO
{
	// User control code here, inside the loop
	//	StartTask(drivemode);
	StartTask (omnidrive);

	while (true)
	{
		flip();
		nomnomatron();

		if(drivey)
		{
			manuallift();
		}
		else
		{
			makro();
			//	macrolifts();
		}

		if(vexRT[Btn7U])				//Changes lift mode
		{
			drivey = true;
		}
		if(vexRT[Btn7D])
		{
			drivey = false;
		}

	}
}
//USELESS JUNK STOP HERE####USELESS JUNK STOP HERE####USELESS JUNK STOP HERE####USELESS JUNK STOP HERE####USELESS JUNK STOP HERE####USELESS JUNK STOP HERE####USELESS JUNK STOP HERE####

/*
void liftx()
{
if(vexRT[Btn5U]) //if the up button is pressed the motor will go up until it hits the top, then it will stop being powered.
{
if(nMotorEncoder[leftlifts] < 209)
{
motor[leftlifts] = 127;
}
else
{
motor[leftlifts] = 0;
}

if(nMotorEncoder[rightlifts] < 209)
{
motor[rightlifts] = 127;
}
else
{
motor[rightlifts] = 0;
}
}

if(vexRT[Btn5D])
{
if(nMotorEncoder[leftlifts] > 0)
motor[leftlifts] = -127;
else
motor[leftlifts] = 0;


if(nMotorEncoder[rightlifts] > 0)
motor[rightlifts] = -127;
else
motor[leftlifts] = 0;
}
}

*/


//void macrolifts()
//{

//	if(vexRT[Btn5U]) //
//	{

//			if(SensorValue(limit) == 0)
//		{
//	while(SensorValue(limit) == 0)
//			{
//				motor[leftlifts] = -127;
//				motor[rightlifts] = -127;
//			}
//			nMotorEncoder[leftlifts] = 0;
//			nMotorEncoder[rightlifts] = 0;
//		}

//	while(nMotorEncoder[leftlifts] < 609)
//	{
//		motor[leftlifts] = 127;

//		while(nMotorEncoder[rightlifts] < 609)			//nested so that both happen at the same time and stop at the same time
//		{
//			motor[rightlifts] = 127;
//		}
//	}

//	motor[leftlifts] = 0;
//	motor[rightlifts] = 0;
//}

//if(vexRT[Btn5D])
//{
//	while(SensorValue(limit) == 0)
//	{
//		motor[leftlifts] = -127;
//		motor[rightlifts] = -127;
//	}
//	motor[leftlifts] = 0;
//	motor[rightlifts] = 0;
//}


//}
