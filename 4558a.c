#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    autonSelect,    sensorPotentiometer)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  button,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,            ,             tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           leftBack,      tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rightBack,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           leftIntake,    tmotorVex393, openLoop)
#pragma config(Motor,  port5,           rightIntake,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           leftVert,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           rightVert,     tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port8,            ,             tmotorVex393, openLoop)
#pragma config(Motor,  port9,            ,             tmotorVex393, openLoop)
#pragma config(Motor,  port10,           ,             tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
void setVertMotors(int value);
void setIntakeMotors(int value);
void setWinchMotors(int value);
void setDriveMotors(int value);
void frontAuto();
void driveMotors(); 	// Function declaration, tells the program that "Hey! I exist!"
void verticals();
void intakes();
void winch();
void redRight();
void redLeft();
void blueRight();
void blueLeft();
int drivingThreshhold = 50; // Driving Threshhold, preserves Motors and stops cluttered movement.
bool continuous = false;
bool downWas = false;

/*-----------------------------------------------------------------------------------------------------*\
|*                                       - 4558A Code 12/9/13 -                                        *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                       *|
|*                                                                                                     *|
|*    MOTORS & SENSORS:                                                                                *|
|*    [I/O Port]          [Name]              [Type]                [Description]                      *|
|*    Motor   - Port 1                         VEX 393 module        Left side intake motor, reversed  *|
|*    Motor   - Port 2     leftBack            VEX 393 module        Left side, rear motor             *|
|*    Motor   - Port 3     rightBack           VEX 393 module        Right side, rear motor            *|
|*    Motor   - Port 4     leftIntake          VEX 393 module        Left side, front motor            *|
|*    Motor   - Port 5     rightIntake         VEX 393 module        Right side, front motor           *|
|*    Motor   - Port 6     leftVert            VEX 393 module        Left side lift motor, reversed    *|
|*    Motor   - Port 7     rightVert           VEX 393 module        Right side lift motor             *|
|*    Motor   - Port 8     winch1              VEX 393 module        Right side winch motor, reversed  *|
|*    Motor   - Port 9     winch2              VEX 393 module        Left side winch motor             *|
|*    Motor   - Port 10                        VEX 393 module        Right side motor                  *|
|*    Analog  - Port 1     autonSelect         VEX Potentiometer     Center								             *|
|*    Analog  - Port 2     lineTracker         VEX Light Sensor      Front-center, facing down         *|
|*		Digital - Port 1		 button							 Touch								 Right brace, facing out					 *|
|*																																																		 *|
|*		ENCODERS:																																												 *|
|*  	[I2C Address]				[Motor Name]																																 *|
|*		I2C_1								rightVert																																		 *|
|*		I2C_2								rightBack																													  				 *|
|*		I2C_3								leftBack																																		 *|
\*------------------------------------------------------------------------------------------------4246-*/




void pre_auton()
{
	nMotorEncoder[leftBack] = 0;
  nMotorEncoder[rightBack] = 0;
  nMotorEncoder[rightVert] = 0;
	bStopTasksBetweenModes = true;
}

task autonomous()
{
	nMotorEncoder[leftVert] = 0;
// 0-4950
	// Potentiometer readings range from 0 - 4095
	if (SensorValue[autonSelect] < 1020)	// First quadrant
		redLeft();  // Red Alliance Left Starting Tile (Infront of bump)
	else if (SensorValue[autonSelect] < 2040)	// Second quadrant
		redRight();  // Red Alliance Right Starting Tile (Behind bump)
  else if (SensorValue[autonSelect] < 3060)	// Third quadrant
		blueLeft();  // Blue Alliacne Left Starting Tile (Behind bump)
	else  // Fourth quadrant
		blueRight();  // Blue Alliance Right Starting Tile (Infront of bump)


}

void redRight()
{
	motor[leftBack] = -100;
	motor[rightBack] = -100;
	Sleep(800);
	motor[leftBack] = 100;
	Sleep(400);
	motor[rightBack] = 100;
	Sleep(3000);
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}

void redLeft()
{
frontAuto();
Sleep(3000);
frontAuto();

}

void blueRight()
{
frontAuto();
Sleep(3000);
frontAuto();
}

void frontAuto()
{
	nMotorEncoder[rightBack] = 0;

	while (nMotorEncoder[rightBack] < 1200)
	{

		if (SensorValue[liftPot] < 1000)
			setVertMotors(127);
  	else
			setVertMotors(0);


		setDriveMotors(127);
	}

	setVertMotors(0);

	nMotorEncoder[rightBack] = 0;



	while (nMotorEncoder[rightBack] > -1200)
	{
		setDriveMotors(-127);
	}

	setDriveMotors(0);
}

void blueLeft()
{
	motor[leftBack] = -100;
	motor[rightBack] = -100;
	Sleep(800);
	motor[rightBack] = 100;
	Sleep(400);
	motor[leftBack] = 100;
	Sleep(3000);
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}

//----------------------------------------------------------------------------------------------
//-----------------------------------END OF AUTONOMOUS------------------------------------------
//----------------------------------------------------------------------------------------------

task usercontrol()
{
	while (true)
	{
		driveMotors(); // Function call to the driving motors
		verticals(); 	 // Function call to the lifts
		intakes(); 		 // Function call to the intake rollers
		winch();			 // Function call to the winch motors
	}
}

void setDriveMotors(int value)
{
	motor[leftBack] = value;
	motor[rightBack] = value;
}

void setVertMotors(int value)
{
	  motor[rightVert] = value;
		motor[leftVert] = value;
}

void setIntakeMotors(int value)
{
	  motor[rightIntake] = value;
		motor[leftIntake] = value;
}

void setWinchMotors(int value)
{
	// motor[winch1] = value;
	//	motor[winch2] = value;
}

void driveMotors()
{
	// Left Wheel
	if (vexRT(Ch3) > drivingThreshhold)
		motor[leftBack] = vexRT(Ch3) / 1.5; 			// Decrease the number to make the motor faster
	else if (vexRT(Ch3) < -drivingThreshhold)
		motor[leftBack] = vexRT(Ch3);					  	// Decrease the number to make the motor faster
	else
		motor[leftBack] = 0; 											// If the joystick's value is below the driving threshhold, turn the motor off

	// Right Wheel
	if (vexRT(Ch2) > drivingThreshhold)
		motor[rightBack] = vexRT(Ch2) / 1.5; 			// Decrease the number to make the motor faster
	else if (vexRT(Ch2) < -drivingThreshhold)
		motor[rightBack] = vexRT(Ch2); 						// Decrease the number to make the motor faster
	else
		motor[rightBack] = 0; 										// If the joystick's value is below the driving threshhold, turn the motor off
}

void verticals()
{
	if (vexRT(Btn5U) == 1 /*&& nMotorEncoder[rightVert] >= -400*/) //-200
		setVertMotors(127);
	else if (vexRT(Btn5D) == 1)
  	setVertMotors(-65);
	else
  	setVertMotors(0);
}

void intakes()
{
	if (vexRT(Btn6U) == 1 && continuous == false)
	{
		continuous = true;
		downWas = false;

		if (abs(motor[leftIntake]) == 127)
  		setIntakeMotors(0);
		else
  		setIntakeMotors(127);
	}
	else if (vexRT(Btn6D) == 0 && vexRT(Btn6U) == 0 && continuous == true)
		continuous = false;


	if (vexRT(Btn6D) == 1 && vexRT(Btn6U) == 0)
	{
  	setIntakeMotors(-127);
		downWas = true;
	}
	else if (vexRT(Btn6D) == 0 && vexRT(Btn6U) == 0 && continuous == false && downWas == true)
  	setIntakeMotors(0);

}

void winch()
{
	if (vexRT(Btn7U) == 1)
		setWinchMotors(100);
	else if (vexRT(Btn7D) == 1)
		setWinchMotors(-127);
	else
		setWinchMotors(0);
}


/*   My Quick Guide:
motor[#] - sets the motors rotation speed. negative is ccwise, positive is cwise
vexRT(Ch#) - this gives you the value of the two joysticks on the controller.
the # represents the joystick and its direction.


Left Joystick          Right Joystick
/0
       3(+)                    2(+)
       |                       |
4(-) --+-- 4(+)         1(-) --+-- 1(+)
       |                       |
       3(-)                    2(-)

vexRT(Btn#) - this returns a boolean value for buttons. if the button is pressed,
return a 1, otherwise, return 0 # represents which button you want.

  5D              6D
  ___             ___                           O
  ___             ___                          O O - D-Pad
  5U              6U                            O
                                                 ___ - Triggers
    U               U                            ___
    O               O
L O 7 O R       L O 8 O R
    O               O
    D               D

abs() - the absolute value of whatever is in the parenthesis
*/

//////////////////////////////////////////////////////////////////////////////////////////////
//**************************************** OLD CODE ****************************************//
//////////////////////////////////////////////////////////////////////////////////////////////

/*
// Middle Wheel, adapted so you can use either joystick to move the wheel
if (abs(vexRT(Ch4)) > drivingThreshhold )
	motor[middleMotor] = vexRT(Ch4) / 1.5;
else if (abs(vexRT(Ch1)) > drivingThreshhold)
	motor[middleMotor] = vexRT(Ch1) / 1.5;
else
	motor[middleMotor] = 0;
*/
/*
// Middle Wheel, adapted so you for buttons to move the wheel
if (vexRT(Btn7L) == 1)
	motor[middleMotor] = 124;
else if (vexRT(Btn7R) == 1)
	motor[middleMotor] = -124;
else
	motor[middleMotor] = 0;
*/
/*
// Lift with Servos
if (vexRT(Btn5D) == 1)
{
	motor[rightVert] -= 10;
	motor[leftVert] -= 10;
	Sleep(100);
}
else if (vexRT(Btn5U) == 1)
{
	motor[rightVert] += 10;
	motor[leftVert] += 10;
	Sleep(100);
}
*/
/*
// Intakes
if ((vexRT(Btn7U) == 1 || vexRT(Btn7D) == 1) && continuous == false)
{
	continuous = true;

	if (abs(motor[leftIntake]) == 80)
	{
		motor[leftIntake] = 0;
		motor[rightIntake] = 0;
	}
	else if (vexRT(Btn7U) == 1)
	{
		motor[leftIntake] = 80;
		motor[rightIntake] = 80;
	}
	else
	{
		motor[leftIntake] = -80;
		motor[rightIntake] = -80;
	}
}
else if (vexRT(Btn7D) == 0 && vexRT(Btn7U) == 0 && continuous == true)
	continuous = false;
*/

/*
while(SensorValue[button] == false) //press button to cotinue...
{}
   Sleep(2000); // This autonomous is not usable. ts meant for a rough understanding of what we want the robot to do
		motor[leftMotor] = -100;
		motor[rightMotor] = -100;
		motorEncoders(100,100);
		Sleep(800);
		motor[rightMotor] = 100;
		Sleep(400);
		motor[leftMotor] = 100;
		Sleep(6000);
		motor[leftMotor] = 0;
		motor[rightMotor] = 0;
*/

/*
void motorEncoders(int left, int right)
{
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	bool rt = true;
	bool lt = true;

	if ( nMotorEncoder[leftMotor] >= left && nMotorEncoder[rightMotor] >= right)
	{
		while(rt || lt)
		{
			re = nMotorEncoder[rightMotor];
			le = nMotorEncoder[leftMotor];
			Sleep(10);
			if (nMotorEncoder[leftMotor] <= left)
				lt = false;
			if (nMotorEncoder[rightMotor] <= right)
				rt = false;
		}
	}
	else if ( nMotorEncoder[leftMotor] <= left && nMotorEncoder[rightMotor] <= right)
	{
		while(rt || lt)
		{
			re = nMotorEncoder[rightMotor];
			le = nMotorEncoder[leftMotor];
			Sleep(10);
			if (nMotorEncoder[leftMotor] >= left)
				lt = false;
			if (nMotorEncoder[rightMotor] >= right)
				rt = false;
		}
	}
	else if ( nMotorEncoder[leftMotor] >= left && nMotorEncoder[rightMotor] <= right)
	{
		while(rt || lt)
		{
			re = nMotorEncoder[rightMotor];
			le = nMotorEncoder[leftMotor];
			Sleep(10);
			if (nMotorEncoder[leftMotor] <= left)
				lt = false;
			if (nMotorEncoder[rightMotor] >= right)
				rt = false;
		}
	}
	else if ( nMotorEncoder[leftMotor] <= left && nMotorEncoder[rightMotor] >= right)
	{
		while(rt || lt)
		{
			re = nMotorEncoder[rightMotor];
			le = nMotorEncoder[leftMotor];
			Sleep(10);
			if (nMotorEncoder[leftMotor] >= left)
				lt = false;
			if (nMotorEncoder[rightMotor] <= right)
				rt = false;
		}
	}
}



Example Atonomous

	motor[leftVert] = 90;
	motor[rightVert] = 90;
	motor[rightMotor] = 100;
	motor[leftMotor] = 100;
	Sleep(5000);
	motor[leftVert] = 0;
	motor[rightVert] = 0;
	motor[leftMotor] = -100;
	motor[rightMotor] = -100;
	Sleep(5000);
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;

*/
